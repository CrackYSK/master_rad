\documentclass[12pt,oneside]{memoir}

\usepackage[biblatex]{matfmaster}

\bib{master}

\autor{Сретен Ковачевић}

\naslov{v8 - имплементација неоптимизујућег WebAssembly компилатора за MIPS архитектуру}

\godina{2018}

\mentor{др Филип \textsc{Марић}, ванредни професор\\ Универзитет у Београду, Математички факултет}

\komisijaA{др Милена \textsc{Вујошевић-Јаничић}, ванредни професор\\ Универзитет у Београду, Математички факултет}

\komisijaB{др Милан \textsc{Банковић}, доцент\\ Универзитет у Београду, Математички факултет}

\apstr{
}

\kljucnereci{}

\begin{document}

\frontmatter

\naslovna

\komisija

\posveta{}

\apstrakt

\tableofcontents*

\mainmatter

\chapter{Увод}

\chapter{Архитектура \textit{MIPS}}

У овој глави је описана архитектура \textit{MIPS} процесора. У поглављу \ref{chp:CR} су описане архитектура
процесора \textit{CISC} (скраћено од енгл. \textit{Complex Instruction Set Computing}) и \textit{RISC} (скраћено од
енгл. \textit{Reduced Instruction Set Computing}) и њихове разлике, а у поглављу \ref{chp:MIPS} \textit{MIPS}
архитектура. У поглављима \ref{chp:INS} и \ref{chp:REG} описане су инструкције и регистри \textit{MIPS} архитектуре.
У поглављу \ref{chp:PIPE} описан је механизам проточне обраде и њена имплементација на \textit{MIPS} архитектури, а у поглављлу \ref{chp:DELAY} је представљен слот закашњења.

\section{\textit{CISC} и \textit{RISC} архитектура} \label{chp:CR}

Архитектура у рачунарству представља спој организације (начин комуникације међу различитим деловима рачунара),
хардвера (примена конкретних логичких кола) и скуп инструкција и регистара \textit{ISA} (скраћено од енгл.
\textit{Instruction Set Architecture}) \cite{ARCH}. Да би разумели разлику између \textit{CISC} (скраћено од енгл.
\textit{Complex Instruction Set Computing}) и \textit{RISC} (скраћено од енгл. \textit{Reduced Instruction Set
Computing}) архитектуре довољно је да посматрамо последњу ставку.

Процесори дизајнирани по \textit{CISC} архитектури карактеришу се великим бројем инструкција које су на раслопагању
програмеру. Овим дизајном се смањује број наредби у програму, по цену броја циклуса по инструкцији. Смањењем броја
инструкција по програму постиже се мања потрошња меморије \cite{CR}. Инструкције често имају различиту дужину
записа, а могу и обављати неколико независних задатака. Оваква архитектура захтева сложен хардвер, што може довести
до потешкоћа у разумевању и програмирању оваквих чипова. Пружају могућност великог броја различитих начина
адресирања. Овакви процесори се користе на личним рачунарима, радним станицама и серверима. Типичан пример је
\textit{Intel x86} серија процесора.

\textit{RISC} архитектура користи високо оптимизован скуп инструкција. Мотив је супротан у односу на мотив
\textit{CISC} архитектуре. Смањује се број циклуса по инструкцији, али се зато добија мањи број инструкција, те је
потребан већи број инструкција по програму. Јединствена карактеристика \textit{RISC} архитектуре је проточна обрада
(енгл. \textit{Pipelining}). Проточна обрада се постиже преклапањем извршавања већег броја инструкција. Захвањујући
томе постижу се боље перформансе у поређењу са \textit{CISC} процесорима \cite{CR}. Како је број инструкција које су
подржане мали, имплементација самог чипа је знатно једноставнија и јефтинија. Подржана су четири начина адресирања:
регистарско, \textit{PC}-релативно, псеудо-директно и базно. Процесори \textit{RISC} архитектуре се користе у
наменским уређајима (енгл. \textit{embedded}) и примери су \textit{ARM} и \textit{MIPS}.

\section{\textit{MIPS}} \label{chp:MIPS}

\textit{MIPS} је представник \textit{RISC} архитектуре, настао средином осамдесетих година двадесетог века на
Станфорд универзитету. Група студената, предвођена Џоном Хенесијем, је истраживала рад \textit{RISC} процесора и
открила да се бољом применом проточне обраде, која је до тад била недовољно искоришћена, може доћи до бржих
процесора на мањем чипу. \textit{MIPS} је током година успео да се одржи на тржишту, али и да сачува епитет једне од
најједноставнијих архитектура \cite{SMR}.

Процесори из \textit{MIPS} породице успели су да пронађу примену у наменским уређајима. Могу се наћи у мобилним
уређајима, мрежним уређајима, сет-топ боксовима, паметним телевизорима. Све претходно наведене примене захтевају
покретање апликација које захтевају интензивна израчунавања (процесирање слика и видеа, анализа података,
интеракција међу субјектима, итд.).

\section{Инструкције} \label{chp:INS}

У \textit{MIPS} асемблерском језику све инструкције су једнаке дужине 32 бита. Могу се поделити у следеће групе
\cite{ISA}:

\begin{itemize}
	\item аритметичке: сабирање, одузимање, множење, дељење
	\item логичке: и, или, шифтовање
	\item приступ меморији: учитавање, записивање у меморију
	\item гранања и скокови
	\item контролне
\end{itemize}
На основу типова операнада, инструкције се могу поделити у три типа \cite{SMR}:

\textbf{R} - Инструкције које као операнд очекују регистре. Представљају се у следећем формату:

$$
OP\ rd, rs, rt
$$
$OP$ представља ознаку инструкције, $rd$ је регистар за смештање резултата, док су регистри $rs$ и $rt$ операнди.
Неки од примера ових инструкција су:
\begin{itemize}
	\item \textit{jr} - скакање на адресу смештену у регистру
	\item \textit{slt} - поставља 1 у регистар уколико је први аргумент мањи од другог
	\item \textit{addu} - смештање у регистар збира аргумената, посматрајући аргументе као неозначене целе бројеве
\end{itemize}

\textbf{I} - Инструкције које као операнде имају регистар и константну вредност, у облику специјалне вредности која
је уписана у инструкцију (енгл. \textit{Immediate}), представљају се форматом:

$$
OP\ rd, rs, Imm
$$
$OP$ представља ознаку инструкције, $rd$ је регистар за смештање резултата, $rs$ први операнд (регистар), а $Imm$
представља константу која је други операнд. Константа може имати највише 16 бита. Примери ових инструкција су:
\begin{itemize}
	\item \textit{lw} - учитавање вредности са адресе $rs+Imm$ у одредишни регистар
	\item \textit{sw} - смештање вредности из одредишног регистра на адресу $rs+Imm$
	\item \textit{beq} - гранање уколико је вредност у регистру једнака константи
	\item \textit{addiu} - смештање у регистар збира вредности из регистра и константе
\end{itemize}

\textbf{J} - Инструкције које се користе при скоковима. Представљају се следећим форматом:

$$
j\ label
$$
Постоје две инструкције овог типа, а то су \textit{j} и \textit{jal}. Код прве инструкције (енгл. \textit{Jump}) се
ток извршавања пребацује на позицију \textit{label}, исто се дешава и са другом инструкцијом (енгл. \textit{Jump and
link}), али се и адреса наредне инструкције уписује у \textit{\$ra} регистар. Ове инструкције прихватају највеће
константе, које су дужине 26 бита, што је оправдано великим бројевима којим се представљају адресе.

\section{Регистри} \label{chp:REG}

Регистри представљају малу, веома ефикасну меморију која се налази у процесору. \textit{MIPS} инструкције могу као
аргументе да примају једино регистре и специјалне константе.У \textit{MIPS} архитектури постоје 32 регистра опште
намене, од којих два имају другачије понашање \cite{SMR}:

\textbf{\$0} - Увек враћа нулу, без обзира шта се у њега уписује

\textbf{ra} - Користи се за смештање адресе повратка из функције приликом коришћења \textit{jal}
инструкције
Сви остали регистри могу се равноправно користити у инструкцијама (чак се и регистар \$0 може користити, али ће ре
резултат у том случају бити занемарен).

У наставку ће бити описани регистри, као и њихово препоручено коришћење:

\textbf{at} - Резервисан за псеудоинструкције које генерише асемблер.

\textbf{v0, v1} - Користе се за смештање целобројних повратних вредности функција. Уколико се резултат не може
сместити у два регистра, компилатор ће резултат сместити у меморију, а адресу у ове регистре.

\textbf{a0 - a3} - Користе се за смештање прва четири целобројна аргумента при позиву функција. Остали се смештају
на стек.

\textbf{t0 - t9} - Привремени регистри, није потребно рестаурирати вредност након коришћења.

\textbf{s0 - s7} - Садржај ових регистара мора остати непромењен након сваке функције, што се постиже привременим
чувањем њиховог садржаја на стеку уколико се користе. Дужност да сачува њихову вредност има позвана функција (енгл.
\textit{callee saved registers}).

\textbf{k0, k1} - Резервисани за системе прекида оперативног система, иначе се ретко користе.

\textbf{gp} - Има два начина примене. Уколико се ради о коду који не зависи од позиције (енгл. \textit{Position
Independent Code} скраћено \textit{PIC}), овај регистар показује на табелу показивача (енгл. \textit{Global Offset
Table}). Уколико је у питању регуларан код, показује на средину у статичкој меморији. На тај начин се помоћу једне
инструкције може приступити било ком податку који је 32KB лево или десно од њега. Овај регистар не користе сви
системи за компилацију и сва окружења за извршавање.

\textbf{sp} - Показивач на стек. Стање стека је потребно експлицитно ажурирати, те се инструкције за одржавање
показивача на стек углавном генеришу на почетку и на крају функција. Како стек расте надоле, на почетку функције се
поставља на најнижу тачку до које ће стек расти.

\textbf{fp} - Показивач на стек оквир. Користи се од стране функције, за праћење стања на стеку. Уколико се при
превођењу не може одредити на коју вредност да се постави \textbf{sp} регистар, променљивим на стеку се приступа
помоћу овог регистра.

\textbf{ra} - Подразумевани регистар за смештање адресе повратка из функције. Овакво понашање је подржано кроз
одговарајуће инструкције скока. Ово је разлика у односу на \textit{x86} архитектуру, где се адреса повратка смешта
на стек. Функције се углавном завршавају наредбом \textit{jr \$ra}. Иако се може користити и било који други
регистар, то се не препоручује због оптимизација које врши процесор у случају коришћења овог регистра. Функције које
позивају друге функције морају сачувати његову вредност.

\section{Проточна обрада} \label{chp:PIPE}

Проточна обрада (енгл. \textit{pipelining}) почива на чињеници да различите фазе извршавања користе различите
ресурсе. Уколико имамо систем у ком је свака фаза једнаке дужине, добили би систем код ког би на крају завршетка
фазе за једну инструкцију у ту фазу ушла следећа инструкција \cite{SMR}. Да би овакав систем био могућ, процесори
\textit{RISC} архитектуре бирају минималан скуп инструкција које имају приближно исто време извршавања у свакој
фази. Такође, инструкције су исте дужине како би се осигурало да је фаза декодирања идентична у свакој фази. Оваква
конфигурација може се видети и у \textit{MIPS} архитектури \cite{SMR}.

Како би проточна обрада била ефикасна користи се кеш меморија, чиме се убрзавају приступи меморији. Кеш меморија је
мала, веома брза, локална меморија у којој се налази копија података из меморије \cite{SMR}. У кешу се чувају подаци
које је процесор најскорије користио, док се најстарији подаци преписују (уколико је кеш попуњен). Када процесор
у кешу не пронађе потребне податке ("промашај кеша", дешава се у 10\% случајева), тада се приступа меморији.

Код \textit{RISC} архитектуре, кеш је уско повезан за процесор и активно се користи за имплементацију проточне
обраде, док се код \textit{CISC} архитектуре кеш посматра као део меморијског система. \textit{MIPS} има одвојен кеш
података и инструкцијски кеш, што омогућава симултано читање инструкција и уписивање или читање података.

\textit{MIPS} инструкције су подељене у пет фаза, и трајање сваке фазе је фиксирано. Прва, трећа и четврта фаза
трају по један такт процесора, док друга и пета захтевају пола такта за своје извршење \cite{SMR}. У наставку је
описана свака од фаза.

\begin{enumerate}
	\item Дохватање инструкције из инструкцијског кеша и њено декодирање
	\item Читање садржаја наведених регистара
	\item Извршавање аритметичко/логичких операција у једном такту (операције у покретном зарезу, множење и дељење су
	сложеније и раде се другачије)
	\item Дохватање и уписивање у меморију. У 75\% случајева инструкције не раде ништа у овој фази, али она постоји
	да не би више инструкција чекало на приступ кешу података
	\item Резултат операције се уписује у одредишни регистар
\end{enumerate}

\section{Слот закашњења} \label{chp:DELAY}

Слот закашњења (енгл. \textit{Delay slot}) је најосетнији ефекат проточне обраде из угла програмера. Због структуре
проточне обраде на \textit{MIPS} архитектури (која је описана у поглављу \ref{chp:PIPE}), у тренутку када наредбе
гранања или скока дођу до фазе извршавања, рад на наредној инструкцији ће већ бити започет, иако је ток извршавања
потенцијално промењен. Започета инструкција се извршава без обзира на исход наредбе промене тока извршавања и на тај
начин се започети посао не одбацује.

Како би се постигло да се у слоту закашњења не појави више од једне инструкције, наредбе гранања имају посебно
понашање при ком се већ после пола такта у фази извршавања аритметичко/логиких операција зна где ће се извршавање
наставити. Како и друга фаза траје пола такта, овим смо обезбедили да само једна инструкција може доспети до прве
фазе, за чије обављање је потребан један такт. Оваква конфигурација пружа могућност програмеру или компилатору да
промени редослед инструкција у програму и тако неко израчунавање смести у слот закашњења \cite{SMR}.

Упркос уштеди коју слот закашњења може да донесе, он представља и потенцијални ризик. Посебно треба истаћи условна
гранања, у којима нека операција не треба да буде извршена у оба случаја. Некад је безбедније (или једино исправно)
оставити у слоту закашњења инструкцију \textit{nop}.

Још једна последица проточне обраде је и слот закашњења учитавања (енгл. \textit{load delay slot}). Подаци дохваћени
\textit{load} инструкцијом постају расположиви тек након инструкције која следи иза ње. Стога се њен резултат не
може користити у следећој инструкцији. Модерни процесори имају механизам блокирања резултата \textit{load}
инструкције. Уколико резултат проба да се искористи у следећој инструкцији, процесор ће зауставити извршавање док
резултат не буде спреман. На ранијим верзијама такав код је имао недефинисано понашање \cite{SMR}.

% TODO: Dodati poglavlje o Endianness-u.

\chapter{WebAssembly}

\textit{WebAssembly} (скраћено \textit{Wasm}) је безбедан и преносив код ниског нивоа. Дизајниран је са
идејом да обезбеди ефикасно извршавање и компактну репрезентацију. Главни циљ му је да омогући функционисање
апликација високог нивоа на Вебу, али и да не прави никакве претпоставке о окружењу нити уводи нове функционалности,
што би га чинило погодним за коришћење у оквиру других окружења \cite{WASM}. У овој глави ће бити описан
\textit{WebAssembly} и његове карактеристике. У поглављу \ref{chp:DESIGN} ће бити приказан дизајн
\textit{WebAssembly}-ja, као и карактеристике које са њим долазе, а у поглављу \ref{chp:STRUCT} је описана његова
структура. У поглављу \ref{chp:PHASES} је дат приказ семантичких фаза.

\section{Дизајн} \label{chp:DESIGN}

Пред \textit{WebAssembly} су постављени одређени циљеви у погледу дизајна. Два основна циља су брза, безбедена и
преносива семантика и ефикасна и преносива репрезентација. Оба циља са својим испуњењем језику пружају
карактеристике неопходне да се постигне жељени ниво перформанси.

Из угла семантике \textit{WebAssembly} je \cite{WASM}:

\begin{itemize}
	\item Брз - извршава се ефикасношћу која тежи ефикасности језика нижег нивоа (енгл. \textit{native}), користећи
	предности савременог хардвера
	\item Безбедан - код се валидира и извршава меморијском сефу, заштићеном окрружењу које спречава угрожавање
	података или упаде
	\item Добро дефинисан - потпуно и прецизно дефинише исправне програме и њихово понашање на начин који је лако
	разумети, како формално тако и неформално
	\item Хардверски независтан - може се превести на свим архитектурама, персоналним и преносивим рачунарима и
	наменским уређајима
	\item Језички независтан - не фаворизује одређени језик вишег нивоа, стил програмирања или објектни модел
	\item Платформски независтан - може бити уграђен у прегледач, представљати самосталну виртуелну машину или
	представљати део неког већег окружења
	\item Отворен - програми могу комуницирати са окружењем користећи једноставне методе
\end{itemize}
Посматрајући репрезентацију \textit{WebAssembly}-ja, можемо закључити да је \cite{WASM}:

\begin{itemize}
	\item Компактан - бинарни формат се брзо преноси захваљујући запису који је краћи и од обичног текста и од кода
	на језику ниског нивоа
	\item Модуларан - програм се може поделити на мање целине које се могу слати, кеширати и користити независно
	\item Ефикасан - може се декодирати, валидирати и компилирати у једном пролазу, како са \textit{JIT} (скраћено од 
	енгл. \textit{Just-in-time}) тако и са \textit{AOT} (скраћено од енгл. \textit{Ahead-of-time}) компилацијом.
	\item Проточан (енгл. \textit{streamable}) - омогућује да декодирање, валидација и компилација почну пре него што
	су сви подаци на располагању
	\item Паралелизабилан (енгл. \textit{parallelizable}) - допушта да декодирање, валидација и компилација буду
	издељени у више независних паралелних задатака
	\item Преносив - не прави претпоставке о архитектури које нису широко распрострањене међу модерним хардвером
\end{itemize}

\section{Структура} \label{chp:STRUCT}

\textit{WebAssembly} кодира језик ниског нивоа, који је налик на асемблер. Његову структуру чине \cite{WASM}:

\begin{itemize}
	\item Вредности
	\item Инструкције
	\item Замке (енгл. \textit{Traps})
	\item Функције
	\item Табеле
	\item Линеарна меморија
	\item Модули
	\item Уграђивач (енгл. \textit{Embedder})
\end{itemize}
У наставку ће бити описан сваки од елемената структуре.

\subsection{Вредности}

У оквиру \textit{WebAssembly}-ja постоје четири типа вредности. То су целобројне вредности и бројеви у покретном
зарезу (имплементирани по стандарду \textit{IEEE 754-2008)}, оба у 32-битној и 64-битној варијанти. 32-битне
целобројне вредности се користе и за репрезентацију истинитосних вредности (енгл. \textit{boolean}) и меморијских
адреса. На располагању су све уобичајене операције над овим типовима, као и конверзије међу њима. Не постоји разлика
између означених и неозначених целих бројева, већ се на основу конкретне операције одлучује како ће се број
посматрати \cite{WASM}.

\subsection{Инструкције}

Рачунски модел је заснован на принципима стек машине. Код се састоји од низа инструкција које се редом извршавају.
Инструкције врше промене над подацима који се налазе на имплицитном стеку операнада и могу се поделити у две основне
категорије. Једноставне инструкције са стека узимају аргумент и резултат смештају назад на стек. Контролне
инструкције мењају ток извршавања програма. Програм је добро структуиран, односно подељен у блокове, петље и условне
кодове и наредбе гранања могу да гађају само неке од ових структура \cite{WASM}.

\subsection{Замке}

Неке инструкције, под одговарајућим условима, могу изазвати замку (енгл. \textit{trap}), које прекидају извршавање
програма. \textit{WebAssembly} не поседује механизам за обраду замки, већ се оне прослеђују окружењу, где се хватају
и обрађују на одговарајући начин \cite{WASM}.

\subsection{Функције}

Код је подељен у одвојене функције. Свака функција прима низ вредности као параметре и враћа низ вредности као
резултат\footnote{У тренутној имплементацији може се вратити само један резултат.}. Функције се могу међусобно
позивати, укључујући и рекурзивне позиве. Функције могу декларисати локалне променљиве које се могу користити попут
виртуелних регистара \cite{WASM}.

% TODO: dodati primer funkcije

\subsection{Табеле}

Табела представља низ вредности неког типа. На тај начин се допушта програму да помоћу индекса индиректно приступи
елементу. Тренутно, једини подржани тип је референца на функцију. Захваљујући томе, програм може позивати функције
користећи само индекс табеле. Ово опонаша показивачe на функције \cite{WASM}.

\subsection{Линеарна меморија}

Линеарна меморија је непрекидан, променљив низ сирових бајтова. Таква меморија има иницијалну величину, али се може
динамички проширити. Програм може учитати или уписати вредност у меморију на адресу било ког бајта (укључујући и
непоравнату). Уколико се покуша приступ ван тренутних граница меморије, замка ће бити активирана \cite{WASM}.

\subsection{Модули}

\textit{WebAssembly} у свом бинарном запису узима облик модула. Модул садржи дефиниције функција, табела, и линеарне
меморије. Такође, може садржати и глобалне променљиве и константе. Дефиниције могу бити увезене тако што ћемо
навести модул из ког увозимо и име дефиниције коју увозимо заједно са одговарајућим типом. Опционо, неке дефиниције
могу бити извезене под једним или више различитих имена. Осим дефиниција, могу се додати иницијализациони подаци за
меморије и табеле. Могу садржати и почетне функције, чије извршавање се одвија аутоматски \cite{WASM}.

% TODO: dodati primer modula

\subsection{Уграђивач}

Имплементација \textit{WebAssembly}-ja је углавном уграђена (енгл. \textit{embedded}) у окружење домаћина. То
окружење одређује како ће модули бити учитани, како су увози доступни и како се приступа извезеним дефиницијама.
Детаљи зависе од окружења и нису одређени структуром самог језика \cite{WASM}. Конкретни примери уграђивача биће
приказани касније.

\section{Семантичке фазе} \label{chp:PHASES}

Семантика је подељена у три фазе. За сваки део језика постоји одговарајућа фаза, а оне су \cite{WASM}:

\textbf{Декодирање} - \textit{WebAssembly} модули се шаљу у бинарном облику. Декодирање је процес који форматира и
конвертује бинарни облик у интерну репрезентацију модула. Интерна репрезентација може бити у облику апстрактне
синтаксе, али и конкретан машински код.

% TODO: dodati modul iz primera gore u binarnom formatu
% koristeci https://github.com/WebAssembly/wabt alat

\textbf{Валидација} - Декодирани модул мора бити валидан. Ова фаза проверава услове добре дефинисаности како би се
осигурало да је модул исправан и безбедан. Прецизније, врши се провера типова функција, као и низ инструкција које
јој припадају како би се утврдило да је стек операнада конзистентно коришћен.

\textbf{Извршавање} - Уколико су прве две фазе успешно окончане, модул се може извршити. Сама фаза извршавања се састоји од две подфазе:

\begin{itemize}
	\item Инстанцирање (енгл. \textit{Instantiation})- Инстанца модула је његова динамичка репрезентација, са
	сопственим стањима и стеком извршавања. У овој	фази се извршава тело модула, све увезене дефиниције,
	иницијализују се глобалне променљиве, меморије, табеле и активира се почетна функција (уколико је дефинисана).
	Враћа примерке извоза модула.
	\item Позивање (енгл. \textit{Invocation}) - Jедном када је фаза инстанцирања завршена, њен резултат се може
	користити да се позивају извезене функције из претходно инстанцираног модула. Функцијама се прослеђују
	одговарајући аргументи, а као резултат се добија резултат њиховог извршавања.
\end{itemize}
Фазе инстанцирања и позивања су операције које одређује окружење домаћина.



\chapter{v8}

\chapter{Имплементација}

\chapter{Закључак}

\literatura

\backmatter

\end{document}