\documentclass[12pt,oneside]{memoir}

\usepackage[biblatex]{matfmaster}

\bib{master}

\autor{Сретен Ковачевић}

\naslov{v8 - имплементација неоптимизујућег WebAssembly компилатора за MIPS архитектуру}

\godina{2018}

\mentor{др Филип \textsc{Марић}, ванредни професор\\ Универзитет у Београду, Математички факултет}

\komisijaA{др Милена \textsc{Вујошевић-Јаничић}, ванредни професор\\ Универзитет у Београду, Математички факултет}

\komisijaB{др Милан \textsc{Банковић}, доцент\\ Универзитет у Београду, Математички факултет}

\apstr{
}

\kljucnereci{}

\begin{document}

\frontmatter

\naslovna

\komisija

\posveta{}

\apstrakt

\tableofcontents*

\mainmatter

\chapter{Увод}

\chapter{Архитектура \textit{MIPS}}

У овој глави је описана архитектура \textit{MIPS} процесора. У поглављу \ref{chp:CR} су описане архитектура
процесора \textit{CISC} (скраћено од енгл. \textit{Complex Instruction Set Computing}) и \textit{RISC} (скраћено од
енгл. \textit{Reduced Instruction Set Computing}) и њихове разлике, а у поглављу \ref{chp:MIPS} \textit{MIPS}
архитектура. У поглављима \ref{chp:INS} и \ref{chp:REG} описане су инструкције и регистри \textit{MIPS} архитектуре.
У поглављу \ref{chp:PIPE} описан је механизам проточне обраде и њена имплементација на \textit{MIPS} архитектури, а у поглављлу \ref{chp:DELAY} је представљен слот закашњења.

\section{\textit{CISC} и \textit{RISC} архитектура} \label{chp:CR}

Архитектура у рачунарству представља спој организације (начин комуникације међу различитим деловима рачунара),
хардвера (примена конкретних логичких кола) и скуп инструкција и регистара \textit{ISA} (скраћено од енгл.
\textit{Instruction Set Architecture}) \cite{ARCH}. Да би разумели разлику између \textit{CISC} (скраћено од енгл.
\textit{Complex Instruction Set Computing}) и \textit{RISC} (скраћено од енгл. \textit{Reduced Instruction Set
Computing}) архитектуре довољно је да посматрамо последњу ставку.

Процесори дизајнирани по \textit{CISC} архитектури карактеришу се великим бројем инструкција које су на раслопагању
програмеру. Овим дизајном се смањује број наредби у програму, по цену броја циклуса по инструкцији. Смањењем броја
инструкција по програму постиже се мања потрошња меморије \cite{CR}. Инструкције често имају различиту дужину
записа, а могу и обављати неколико независних задатака. Оваква архитектура захтева сложен хардвер, што може довести
до потешкоћа у разумевању и програмирању оваквих чипова. Пружају могућност великог броја различитих начина
адресирања. Овакви процесори се користе на личним рачунарима, радним станицама и серверима. Типичан пример је
\textit{Intel x86} серија процесора.

\textit{RISC} архитектура користи високо оптимизован скуп инструкција. Мотив је супротан у односу на мотив
\textit{CISC} архитектуре. Смањује се број циклуса по инструкцији, али се зато добија мањи број инструкција, те је
потребан већи број инструкција по програму. Јединствена карактеристика \textit{RISC} архитектуре је проточна обрада
(енгл. \textit{Pipelining}). Проточна обрада се постиже преклапањем извршавања већег броја инструкција. Захвањујући
томе постижу се боље перформансе у поређењу са \textit{CISC} процесорима \cite{CR}. Како је број инструкција које су
подржане мали, имплементација самог чипа је знатно једноставнија и јефтинија. Подржана су четири начина адресирања:
регистарско, \textit{PC}-релативно, псеудо-директно и базно. Процесори \textit{RISC} архитектуре се користе у
наменским уређајима (енгл. \textit{embedded}) и примери су \textit{ARM} и \textit{MIPS}.

\section{\textit{MIPS}} \label{chp:MIPS}

\textit{MIPS} је представник \textit{RISC} архитектуре, настао средином осамдесетих година двадесетог века на
Станфорд универзитету. Група студената, предвођена Џоном Хенесијем, је истраживала рад \textit{RISC} процесора и
открила да се бољом применом проточне обраде, која је до тад била недовољно искоришћена, може доћи до бржих
процесора на мањем чипу. \textit{MIPS} је током година успео да се одржи на тржишту, али и да сачува епитет једне од
најједноставнијих архитектура \cite{SMR}.

Процесори из \textit{MIPS} породице успели су да пронађу примену у наменским уређајима. Могу се наћи у мобилним
уређајима, мрежним уређајима, сет-топ боксовима, паметним телевизорима. Све претходно наведене примене захтевају
покретање апликација које захтевају интензивна израчунавања (процесирање слика и видеа, анализа података,
интеракција међу субјектима, итд.).

\section{Инструкције} \label{chp:INS}

У \textit{MIPS} асемблерском језику све инструкције су једнаке дужине 32 бита. Могу се поделити у следеће групе
\cite{ISA}:

\begin{itemize}
	\item аритметичке: сабирање, одузимање, множење, дељење
	\item логичке: и, или, шифтовање
	\item приступ меморији: учитавање, записивање у меморију
	\item гранања и скокови
	\item контролне
\end{itemize}
На основу типова операнада, инструкције се могу поделити у три типа \cite{SMR}:

\textbf{R} - Инструкције које као операнд очекују регистре. Представљају се у следећем формату:

$$
OP\ rd, rs, rt
$$
$OP$ представља ознаку инструкције, $rd$ је регистар за смештање резултата, док су регистри $rs$ и $rt$ операнди.
Неки од примера ових инструкција су:
\begin{itemize}
	\item \textit{jr} - скакање на адресу смештену у регистру
	\item \textit{slt} - поставља 1 у регистар уколико је први аргумент мањи од другог
	\item \textit{addu} - смештање у регистар збира аргумената, посматрајући аргументе као неозначене целе бројеве
\end{itemize}

\textbf{I} - Инструкције које као операнде имају регистар и константну вредност, у облику специјалне вредности која
је уписана у инструкцију (енгл. \textit{Immediate}), представљају се форматом:

$$
OP\ rd, rs, Imm
$$
$OP$ представља ознаку инструкције, $rd$ је регистар за смештање резултата, $rs$ први операнд (регистар), а $Imm$
представља константу која је други операнд. Константа може имати највише 16 бита. Примери ових инструкција су:
\begin{itemize}
	\item \textit{lw} - учитавање вредности са адресе $rs+Imm$ у одредишни регистар
	\item \textit{sw} - смештање вредности из одредишног регистра на адресу $rs+Imm$
	\item \textit{beq} - гранање уколико је вредност у регистру једнака константи
	\item \textit{addiu} - смештање у регистар збира вредности из регистра и константе
\end{itemize}

\textbf{J} - Инструкције које се користе при скоковима. Представљају се следећим форматом:

$$
j\ label
$$
Постоје две инструкције овог типа, а то су \textit{j} и \textit{jal}. Код прве инструкције (енгл. \textit{Jump}) се
ток извршавања пребацује на позицију \textit{label}, исто се дешава и са другом инструкцијом (енгл. \textit{Jump and
link}), али се и адреса наредне инструкције уписује у \textit{\$ra} регистар. Ове инструкције прихватају највеће
константе, које су дужине 26 бита, што је оправдано великим бројевима којим се представљају адресе.

\section{Регистри} \label{chp:REG}

Регистри представљају малу, веома ефикасну меморију која се налази у процесору. \textit{MIPS} инструкције могу као
аргументе да примају једино регистре и специјалне константе.У \textit{MIPS} архитектури постоје 32 регистра опште
намене, од којих два имају другачије понашање \cite{SMR}:

\textbf{\$0} - Увек враћа нулу, без обзира шта се у њега уписује

\textbf{ra} - Користи се за смештање адресе повратка из функције приликом коришћења \textit{jal}
инструкције
Сви остали регистри могу се равноправно користити у инструкцијама (чак се и регистар \$0 може користити, али ће ре
резултат у том случају бити занемарен).

У наставку ће бити описани регистри, као и њихово препоручено коришћење:

\textbf{at} - Резервисан за псеудоинструкције које генерише асемблер.

\textbf{v0, v1} - Користе се за смештање целобројних повратних вредности функција. Уколико се резултат не може
сместити у два регистра, компилатор ће резултат сместити у меморију, а адресу у ове регистре.

\textbf{a0 - a3} - Користе се за смештање прва четири целобројна аргумента при позиву функција. Остали се смештају
на стек.

\textbf{t0 - t9} - Привремени регистри, није потребно рестаурирати вредност након коришћења.

\textbf{s0 - s7} - Садржај ових регистара мора остати непромењен након сваке функције, што се постиже привременим
чувањем њиховог садржаја на стеку уколико се користе. Дужност да сачува њихову вредност има позвана функција (енгл.
\textit{callee saved registers}).

\textbf{k0, k1} - Резервисани за системе прекида оперативног система, иначе се ретко користе.

\textbf{gp} - Има два начина примене. Уколико се ради о коду који не зависи од позиције (енгл. \textit{Position
Independent Code} скраћено \textit{PIC}), овај регистар показује на табелу показивача (енгл. \textit{Global Offset
Table}). Уколико је у питању регуларан код, показује на средину у статичкој меморији. На тај начин се помоћу једне
инструкције може приступити било ком податку који је 32KB лево или десно од њега. Овај регистар не користе сви
системи за компилацију и сва окружења за извршавање.

\textbf{sp} - Показивач на стек. Стање стека је потребно експлицитно ажурирати, те се инструкције за одржавање
показивача на стек углавном генеришу на почетку и на крају функција. Како стек расте надоле, на почетку функције се
поставља на најнижу тачку до које ће стек расти.

\textbf{fp} - Показивач на стек оквир. Користи се од стране функције, за праћење стања на стеку. Уколико се при
превођењу не може одредити на коју вредност да се постави \textbf{sp} регистар, променљивим на стеку се приступа
помоћу овог регистра.

\textbf{ra} - Подразумевани регистар за смештање адресе повратка из функције. Овакво понашање је подржано кроз
одговарајуће инструкције скока. Ово је разлика у односу на \textit{x86} архитектуру, где се адреса повратка смешта
на стек. Функције се углавном завршавају наредбом \textit{jr \$ra}. Иако се може користити и било који други
регистар, то се не препоручује због оптимизација које врши процесор у случају коришћења овог регистра. Функције које
позивају друге функције морају сачувати његову вредност.

\section{Проточна обрада} \label{chp:PIPE}

Проточна обрада (енгл. \textit{pipelining}) почива на чињеници да различите фазе извршавања користе различите
ресурсе. Уколико имамо систем у ком је свака фаза једнаке дужине, добили би систем код ког би на крају завршетка
фазе за једну инструкцију у ту фазу ушла следећа инструкција \cite{SMR}. Да би овакав систем био могућ, процесори
\textit{RISC} архитектуре бирају минималан скуп инструкција које имају приближно исто време извршавања у свакој
фази. Такође, инструкције су исте дужине како би се осигурало да је фаза декодирања идентична у свакој фази. Оваква
конфигурација може се видети и у \textit{MIPS} архитектури \cite{SMR}.

Како би проточна обрада била ефикасна користи се кеш меморија, чиме се убрзавају приступи меморији. Кеш меморија је
мала, веома брза, локална меморија у којој се налази копија података из меморије \cite{SMR}. У кешу се чувају подаци
које је процесор најскорије користио, док се најстарији подаци преписују (уколико је кеш попуњен). Када процесор
у кешу не пронађе потребне податке ("промашај кеша", дешава се у 10\% случајева), тада се приступа меморији.

Код \textit{RISC} архитектуре, кеш је уско повезан за процесор и активно се користи за имплементацију проточне
обраде, док се код \textit{CISC} архитектуре кеш посматра као део меморијског система. \textit{MIPS} има одвојен кеш
података и инструкцијски кеш, што омогућава симултано читање инструкција и уписивање или читање података.

\textit{MIPS} инструкције су подељене у пет фаза, и трајање сваке фазе је фиксирано. Прва, трећа и четврта фаза
трају по један такт процесора, док друга и пета захтевају пола такта за своје извршење \cite{SMR}. У наставку је
описана свака од фаза.

\begin{enumerate}
	\item Дохватање инструкције из инструкцијског кеша и њено декодирање
	\item Читање садржаја наведених регистара
	\item Извршавање аритметичко/логичких операција у једном такту (операције у покретном зарезу, множење и дељење су
	сложеније и раде се другачије)
	\item Дохватање и уписивање у меморију. У 75\% случајева инструкције не раде ништа у овој фази, али она постоји
	да не би више инструкција чекало на приступ кешу података
	\item Резултат операције се уписује у одредишни регистар
\end{enumerate}

\section{Слот закашњења} \label{chp:DELAY}

Слот закашњења (енгл. \textit{Delay slot}) је најосетнији ефекат проточне обраде из угла програмера. Због структуре
проточне обраде на \textit{MIPS} архитектури (која је описана у поглављу \ref{chp:PIPE}), у тренутку када наредбе
гранања или скока дођу до фазе извршавања, рад на наредној инструкцији ће већ бити започет, иако је ток извршавања
потенцијално промењен. Започета инструкција се извршава без обзира на исход наредбе промене тока извршавања и на тај
начин се започети посао не одбацује.

Како би се постигло да се у слоту закашњења не појави више од једне инструкције, наредбе гранања имају посебно
понашање при ком се већ после пола такта у фази извршавања аритметичко/логиких операција зна где ће се извршавање
наставити. Како и друга фаза траје пола такта, овим смо обезбедили да само једна инструкција може доспети до прве
фазе, за чије обављање је потребан један такт. Оваква конфигурација пружа могућност програмеру или компилатору да
промени редослед инструкција у програму и тако неко израчунавање смести у слот закашњења \cite{SMR}.

Упркос уштеди коју слот закашњења може да донесе, он представља и потенцијални ризик. Посебно треба истаћи условна
гранања, у којима нека операција не треба да буде извршена у оба случаја. Некад је безбедније (или једино исправно)
оставити у слоту закашњења инструкцију \textit{nop}.

Још једна последица проточне обраде је и слот закашњења учитавања (енгл. \textit{load delay slot}). Подаци дохваћени
\textit{load} инструкцијом постају расположиви тек након инструкције која следи иза ње. Стога се њен резултат не
може користити у следећој инструкцији. Модерни процесори имају механизам блокирања резултата \textit{load}
инструкције. Уколико резултат проба да се искористи у следећој инструкцији, процесор ће зауставити извршавање док
резултат не буде спреман. На ранијим верзијама такав код је имао недефинисано понашање \cite{SMR}.

% TODO: Dodati poglavlje o Endianness-u.

\chapter{WebAssembly}

\chapter{v8}

\chapter{Имплементација}

\chapter{Закључак}

\literatura

\backmatter

\end{document}